// Generated by CoffeeScript 1.3.3
var Highlight, MarkdownPage, Page, async, extractMetadata, fs, is_relative, marked, parseMarkdownSync, parseMetadata, path, url,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Highlight = require('highlight').Highlight;

marked = require('marked');

async = require('async');

path = require('path');

url = require('url');

fs = require('fs');

Page = require('./page');

is_relative = function(uri) {
  /* returns true if *uri* is relative; otherwise false
  */
  return !/(^\w+:)|(^\/)/.test(uri);
};

parseMetadata = function(metadata, callback) {
  /* takes *metadata* in the format:
        key: value
        foo: bar
      returns parsed object
  */

  var key, line, lines, pos, rv, value, _i, _len;
  rv = {};
  try {
    lines = metadata.split('\n');
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      pos = line.indexOf(':');
      key = line.slice(0, pos).toLowerCase();
      value = line.slice(pos + 1).trim();
      rv[key] = value;
    }
    return callback(null, rv);
  } catch (error) {
    return callback(error);
  }
};

extractMetadata = function(content, callback) {
  var split_idx;
  split_idx = content.indexOf('\n\n');
  return async.parallel({
    metadata: function(callback) {
      return parseMetadata(content.slice(0, split_idx), callback);
    },
    markdown: function(callback) {
      return callback(null, content.slice(split_idx + 2));
    }
  }, callback);
};

parseMarkdownSync = function(content, baseUrl) {
  /* takes markdown *content* and returns html using *baseUrl* for any relative urls
      returns html
  */

  var token, tokens, _i, _len;
  marked.inlineLexer.formatUrl = function(uri) {
    if (is_relative(uri)) {
      return url.resolve(baseUrl, uri);
    } else {
      return uri;
    }
  };
  tokens = marked.lexer(content);
  for (_i = 0, _len = tokens.length; _i < _len; _i++) {
    token = tokens[_i];
    switch (token.type) {
      case 'code':
        token.text = Highlight(token.text, '  ');
        token.escaped = true;
    }
  }
  return marked.parser(tokens);
};

MarkdownPage = (function(_super) {

  __extends(MarkdownPage, _super);

  function MarkdownPage() {
    return MarkdownPage.__super__.constructor.apply(this, arguments);
  }

  MarkdownPage.prototype.getLocation = function(base) {
    var uri;
    uri = this.getUrl(base);
    return uri.slice(0, uri.lastIndexOf('/') + 1 || 9e9);
  };

  MarkdownPage.prototype.getHtml = function(base) {
    /* parse @markdown and return html. also resolves any relative urls to absolute ones
    */

    var _ref;
    if ((_ref = this._html) == null) {
      this._html = parseMarkdownSync(this._content, this.getLocation(base));
    }
    return this._html;
  };

  return MarkdownPage;

})(Page);

MarkdownPage.fromFile = function(filename, base, callback) {
  var _this = this;
  return async.waterfall([
    function(callback) {
      return fs.readFile(path.join(base, filename), callback);
    }, function(buffer, callback) {
      return extractMetadata(buffer.toString(), callback);
    }, function(result, callback) {
      var markdown, metadata, page;
      markdown = result.markdown, metadata = result.metadata;
      page = new _this(filename, markdown, metadata);
      return callback(null, page);
    }
  ], callback);
};

module.exports = MarkdownPage;
