// Generated by CoffeeScript 1.3.3
var async, defaults, logger, path, readJSON, _ref;

path = require('path');

async = require('async');

_ref = require('../common'), logger = _ref.logger, readJSON = _ref.readJSON;

exports.commonOptions = defaults = {
  config: {
    alias: 'c',
    "default": './config.json'
  },
  contents: {
    alias: 'i',
    "default": './contents'
  },
  templates: {
    alias: 't',
    "default": './templates'
  },
  locals: {
    alias: 'L',
    "default": {}
  },
  chdir: {
    alias: 'C',
    "default": null
  },
  require: {
    alias: 'P',
    "default": []
  },
  plugins: {
    alias: 'P',
    "default": []
  }
};

exports.commonUsage = ["-C, --chdir [path]            change the working directory", "  -c, --config [path]           path to config (defaults to " + defaults.config["default"] + ")", "  -i, --contents [path]         contents location (defaults to " + defaults.contents["default"] + ")", "  -t, --templates [path]        template location (defaults to " + defaults.templates["default"] + ")", "  -L, --locals [path]           optional path to json file containing template context data", "  -R, --require                 comma separated list of modules to add to the template context", "  -P, --plugins                 comma separated list of modules to load as plugins"].join('\n');

exports.getOptions = function(argv, callback) {
  /* resolves options with the hierarchy: argv > configfile > defaults
      returns a options object
  */

  var resolveModule, workDir;
  workDir = path.resolve(argv.chdir || process.cwd());
  logger.verbose("resolving options - work directory: " + workDir);
  resolveModule = function(moduleName, callback) {
    if (moduleName.slice(0, 2) === './') {
      return callback(null, path.resolve(workDir, moduleName));
    } else {
      return callback(null, moduleName);
    }
  };
  return async.waterfall([
    function(callback) {
      var configPath;
      configPath = path.join(workDir, argv.config);
      return path.exists(configPath, function(exists) {
        if (exists) {
          logger.info("using config file: " + configPath);
          return readJSON(configPath, callback);
        } else {
          logger.verbose("no config file found");
          return callback(null, {});
        }
      });
    }, function(options, callback) {
      var key, _i, _len, _ref1, _ref2, _ref3;
      logger.verbose('options:', options);
      for (key in defaults) {
        if ((_ref1 = options[key]) == null) {
          options[key] = defaults[key]["default"];
        }
        if ((argv[key] != null) && argv[key] !== defaults[key]["default"]) {
          options[key] = argv[key];
        }
      }
      for (key in argv) {
        if (key[0] === '_' || key[0] === '$') {
          continue;
        }
        if ((_ref2 = options[key]) == null) {
          options[key] = argv[key];
        }
      }
      _ref3 = ['output', 'config', 'contents', 'templates'];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        key = _ref3[_i];
        if (options[key]) {
          options[key] = path.resolve(workDir, options[key]);
        }
      }
      return callback(null, options);
    }, function(options, callback) {
      var filename;
      if (typeof options.locals === 'string') {
        filename = path.join(workDir, options.locals);
        logger.verbose("loading locals from: " + filename);
        return readJSON(filename, function(error, result) {
          if (error) {
            return callback(error);
          } else {
            options.locals = result;
            return callback(null, options);
          }
        });
      } else {
        return callback(null, options);
      }
    }, function(options, callback) {
      if (typeof options.require === 'string') {
        options.require = options.require.split(',');
      }
      return async.map(options.require, resolveModule, function(error, result) {
        options.require = result;
        return callback(error, options);
      });
    }, function(options, callback) {
      return async.forEach(options.require, function(moduleName, callback) {
        logger.verbose("loading module " + moduleName);
        try {
          options.locals[moduleName] = require(moduleName);
          return callback();
        } catch (error) {
          return callback(error);
        }
      }, function(error) {
        return callback(error, options);
      });
    }, function(options, callback) {
      if (typeof options.plugins === 'string') {
        options.plugins = options.plugins.split(',');
      }
      return async.map(options.plugins, resolveModule, function(error, result) {
        options.plugins = result;
        return callback(error, options);
      });
    }, function(options, callback) {
      var paths;
      logger.verbose('resolved options:', options);
      logger.verbose('validating paths');
      paths = ['contents', 'templates'];
      return async.forEach(paths, function(filepath, callback) {
        return path.exists(options[filepath], function(exists) {
          if (exists) {
            return callback();
          } else {
            return callback(new Error("" + filepath + " path invalid (" + options[filepath] + ")"));
          }
        });
      }, function(error) {
        return callback(error, options);
      });
    }
  ], callback);
};

exports.loadPlugins = function(plugins, callback) {
  var wintersmith;
  require('coffee-script');
  wintersmith = require('./../');
  return async.forEach(plugins, function(plugin, callback) {
    var module;
    logger.verbose("loading plugin: " + plugin);
    try {
      module = require(plugin);
    } catch (error) {
      return callback(error);
    }
    return module(wintersmith, callback);
  }, callback);
};
