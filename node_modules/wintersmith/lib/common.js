// Generated by CoffeeScript 1.3.3
var async, cli, colors, extend, fs, path, rfc822, stripExtension, transports, util, winston,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

winston = require('winston');

colors = require('colors');

util = require('util');

fs = require('fs');

path = require('path');

async = require('async');

extend = function(obj, mixin) {
  var method, name, _results;
  _results = [];
  for (name in mixin) {
    method = mixin[name];
    _results.push(obj[name] = method);
  }
  return _results;
};

exports.extend = extend;

stripExtension = function(filename) {
  return filename.replace(/(.+)\.[^.]+$/, '$1');
};

exports.stripExtension = stripExtension;

rfc822 = function(date) {
  /* return a rfc822 representation of a javascript Date object
      http://www.w3.org/Protocols/rfc822/#z28
  */

  var days, months, pad, time, tzoffset;
  pad = function(i) {
    if (i < 10) {
      return '0' + i;
    } else {
      return i;
    }
  };
  tzoffset = function(offset) {
    var direction, hours, minutes;
    hours = Math.floor(offset / 60);
    minutes = Math.abs(offset % 60);
    direction = hours > 0 ? '-' : '+';
    return direction + pad(Math.abs(hours)) + pad(minutes);
  };
  months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', ' Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  time = [pad(date.getHours()), pad(date.getMinutes()), pad(date.getSeconds())].join(':');
  return [days[date.getDay()] + ',', pad(date.getDate()), months[date.getMonth()], date.getFullYear(), time, tzoffset(date.getTimezoneOffset())].join(' ');
};

exports.rfc822 = rfc822;

cli = (function(_super) {

  __extends(cli, _super);

  cli.prototype.name = 'cli';

  function cli(options) {
    cli.__super__.constructor.call(this, options);
    this.quiet = options.quiet || false;
  }

  cli.prototype.log = function(level, msg, meta, callback) {
    var key, pval, stack, value;
    if (level === 'error') {
      process.stderr.write("\n  error".red + (" " + msg + "\n"));
      if (this.level === 'verbose' && (meta != null)) {
        if (meta.stack != null) {
          stack = meta.stack.substr(meta.stack.indexOf('\n') + 1);
          process.stderr.write(stack + "\n\n");
        }
        for (key in meta) {
          value = meta[key];
          if (key === 'message' || key === 'stack') {
            continue;
          }
          pval = util.inspect(value, false, 2, true).replace(/\n/g, '\n    ');
          process.stderr.write("    " + key + ": " + pval + "\n");
        }
      } else {
        process.stderr.write("\n");
      }
    } else if (!this.quiet) {
      switch (level) {
        case 'verbose':
          msg = msg.yellow;
      }
      if (meta) {
        msg += util.format(' %j', meta);
      }
      process.stdout.write("  " + msg + "\n");
    }
    this.emit('logged');
    return callback(null, true);
  };

  return cli;

})(winston.Transport);

transports = exports.transports = [
  new cli({
    level: 'info'
  })
];

exports.logger = new winston.Logger({
  exitOnError: true,
  transports: transports
});

exports.readJSON = function(filename, callback) {
  /* read and try to parse *filename* as json
  */
  return async.waterfall([
    function(callback) {
      return fs.readFile(filename, callback);
    }, function(buffer, callback) {
      var rv;
      try {
        rv = JSON.parse(buffer.toString());
        return callback(null, rv);
      } catch (error) {
        error.filename = filename;
        error.message = "parsing " + (path.basename(filename)) + ": " + error.message;
        return callback(error);
      }
    }
  ], callback);
};
