// Generated by CoffeeScript 1.3.3
var ContentTree, async, colorCode, colors, extend, fs, loadTemplates, logger, mime, path, run, setup, stripExtension, url, util, _ref, _ref1;

util = require('util');

async = require('async');

fs = require('fs');

path = require('path');

url = require('url');

colors = require('colors');

mime = require('mime');

_ref = require('./common'), logger = _ref.logger, extend = _ref.extend, stripExtension = _ref.stripExtension;

_ref1 = require('./'), loadTemplates = _ref1.loadTemplates, ContentTree = _ref1.ContentTree;

colorCode = function(code) {
  var s;
  s = code.toString();
  switch (Math.floor(code / 100)) {
    case 2:
      return s.green;
    case 4:
      return s.yellow;
    case 5:
      return s.red;
    default:
      return s;
  }
};

setup = function(options, callback) {
  var contentHandler, requestHandler;
  contentHandler = function(request, response, callback) {
    var uri;
    uri = url.parse(request.url).pathname;
    logger.verbose("contentHandler: " + uri);
    return async.waterfall([
      function(callback) {
        return async.parallel({
          templates: async.apply(loadTemplates, options.templates),
          contents: async.apply(ContentTree.fromDirectory, options.contents)
        }, callback);
      }, function(result, callback) {
        var contents, templates;
        contents = result.contents, templates = result.templates;
        return async.detect(ContentTree.flatten(contents), function(item, callback) {
          return callback(uri === item.url);
        }, function(result) {
          if (result) {
            return result.render(options.locals, contents, templates, function(error, res) {
              if (error) {
                return callback(error);
              } else if (res instanceof fs.ReadStream) {
                response.writeHead(200, {
                  'Content-Type': mime.lookup(result.filename)
                });
                return util.pump(res, response, function(error) {
                  return callback(error, 200);
                });
              } else if (res instanceof Buffer) {
                response.writeHead(200, {
                  'Content-Type': mime.lookup(result.filename)
                });
                response.write(res);
                response.end();
                return callback(null, 200);
              } else {
                return callback();
              }
            });
          } else {
            return callback();
          }
        });
      }
    ], callback);
  };
  requestHandler = function(request, response) {
    var start, uri;
    start = new Date();
    uri = url.parse(request.url).pathname;
    return async.waterfall([async.apply(contentHandler, request, response)], function(error, responseCode) {
      var delta;
      if (error || !(responseCode != null)) {
        responseCode = error != null ? 500 : 404;
        response.writeHead(responseCode, {
          'Content-Type': 'text/plain'
        });
        response.end(error != null ? error.message : '404 Not Found\n');
      }
      delta = new Date() - start;
      logger.info(("" + (colorCode(responseCode)) + " " + uri.bold + " ") + ("" + delta + "ms").grey);
      if (error) {
        return logger.error(error.message, error);
      }
    });
  };
  return requestHandler;
};

run = function(options) {
  var http, server, serverUrl;
  http = require('http');
  server = http.createServer(setup(options));
  server.listen(options.port);
  serverUrl = ("http://localhost:" + options.port + "/").bold;
  return logger.info("server running on: " + serverUrl);
};

module.exports = setup;

module.exports.run = run;
