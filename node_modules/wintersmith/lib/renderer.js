// Generated by CoffeeScript 1.3.3
var ContentTree, async, extend, fs, logger, path, render, stripExtension, util, _ref;

fs = require('fs');

util = require('util');

async = require('async');

path = require('path');

_ref = require('./common'), logger = _ref.logger, extend = _ref.extend, stripExtension = _ref.stripExtension;

ContentTree = require('./content').ContentTree;

render = function(contents, templates, location, locals, callback) {
  /* render ContentTree *contents* using *templates* to *location*
      *locals* can be used to provide extra data to all templates
  */

  var renderPlugin, renderTree;
  logger.verbose("rendering into: " + location);
  logger.info("rendering tree:\n" + (ContentTree.inspect(contents, 1)) + "\n");
  locals.contents = contents;
  renderPlugin = function(content, callback) {
    /* render *content* plugin, calls *callback* with true if a file is written;
        otherwise false.
    */

    var destination;
    destination = path.join(location, content.filename);
    logger.verbose("writing content " + content.url + " to " + destination);
    return content.render(locals, contents, templates, function(error, result) {
      var writeStream;
      if (error) {
        return callback(error, false);
      } else if (result instanceof fs.ReadStream || result instanceof Buffer) {
        writeStream = fs.createWriteStream(destination);
        if (result instanceof fs.ReadStream) {
          util.pump(result, writeStream, callback);
        } else {
          writeStream.write(result);
          writeStream.end();
        }
        return callback(null, true);
      } else {
        logger.verbose("skipping " + content.url);
        return callback(null, false);
      }
    });
  };
  renderTree = function(tree, callback) {
    var directory;
    logger.verbose("rendering: " + tree.filename);
    directory = path.join(location, tree.filename);
    return async.waterfall([
      function(callback) {
        return fs.mkdir(directory, function(error) {
          if (!error || error.code === 'EEXIST') {
            return callback();
          } else {
            return callback(error);
          }
        });
      }, function(callback) {
        return async.map(Object.keys(tree), function(key, callback) {
          var item;
          item = tree[key];
          if (item instanceof ContentTree) {
            return renderTree(item, callback);
          } else {
            return renderPlugin(item, callback);
          }
        }, callback);
      }, function(written, callback) {
        var detector;
        detector = function(didWrite, callback) {
          return callback(!didWrite);
        };
        return async.every(written, detector, function(isEmpty) {
          if (isEmpty) {
            logger.verbose("removing empty directory " + directory);
            return fs.rmdir(directory, callback);
          } else {
            return callback();
          }
        });
      }
    ], function(error) {
      return callback(error, true);
    });
  };
  return renderTree(contents, callback);
};

module.exports = render;
