// Generated by CoffeeScript 1.3.3
var ContentPlugin, ContentTree, Model, StaticFile, async, colors, contentPlugins, fs, logger, minimatch, path, registerContentPlugin, slugify, url, util,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

async = require('async');

fs = require('fs');

path = require('path');

url = require('url');

colors = require('colors');

minimatch = require('minimatch');

logger = require('./common').logger;

contentPlugins = [];

registerContentPlugin = function(treeName, handles, plugin) {
  /* register a plugin. arguments:
      *treeName* - name that will be shown in the content tree (eg. 'textFiles')
                   generally a plural name is recommended since it will appear in the content-tree
                   as an array of *plugin* instances (eg. contents.somedir.textFiles)
      *handles*: glob-pattern to match (eg. '** / *.*(txt|text)' )
      *plugin*: the <ContentPlugin> subclass
  */
  return contentPlugins.push({
    treeName: treeName,
    pattern: handles,
    "class": plugin
  });
};

Model = (function() {

  function Model() {}

  Model.property = function(name, method) {
    /* define read-only property with *name*
    */
    return Object.defineProperty(this.prototype, name, {
      get: function() {
        return method.call(this);
      },
      enumerable: true
    });
  };

  return Model;

})();

ContentPlugin = (function(_super) {

  __extends(ContentPlugin, _super);

  function ContentPlugin() {
    return ContentPlugin.__super__.constructor.apply(this, arguments);
  }

  ContentPlugin.prototype.render = function(locals, contents, templates, callback) {
    /* *callback* with a ReadStream/Buffer or null if the contents should not be rendered
        *locals* rendering context variables
        *contents* is the full content tree
        *templates* is a map of all templates as: {filename: templateInstance}
    */
    throw new Error('not implemented');
  };

  ContentPlugin.prototype.getFilename = function() {
    /* return filename for this content
    */
    throw new Error('not implemented');
  };

  ContentPlugin.prototype.getUrl = function(base) {
    var filename;
    if (base == null) {
      base = '/';
    }
    /* return url for this content relative to *base*
    */

    filename = this.getFilename();
    if (!base.match(/\/$/)) {
      base += '/';
    }
    if (process.platform === 'win32') {
      filename = filename.replace(/\\/g, '/');
    }
    return url.resolve(base, filename);
  };

  ContentPlugin.property('url', function() {
    return this.getUrl();
  });

  ContentPlugin.property('filename', function() {
    return this.getFilename();
  });

  return ContentPlugin;

})(Model);

ContentPlugin.fromFile = function(filename, base, callback) {
  /* *callback* with an instance of class. *filename* is the relative filename
      from *base* wich is the working directory (content directory)
  */

};

StaticFile = (function(_super) {

  __extends(StaticFile, _super);

  /* static file handler, simply serves content as-is. last in chain
  */


  function StaticFile(_filename, _base) {
    this._filename = _filename;
    this._base = _base;
  }

  StaticFile.prototype.getFilename = function() {
    return this._filename;
  };

  StaticFile.prototype.render = function() {
    var args, callback, rs, _i;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
    try {
      rs = fs.createReadStream(path.join(this._base, this._filename));
    } catch (error) {
      return callback(error);
    }
    return callback(null, rs);
  };

  return StaticFile;

})(ContentPlugin);

StaticFile.fromFile = function(filename, base, callback) {
  return callback(null, new StaticFile(filename, base));
};

registerContentPlugin('files', '**/*', StaticFile);

slugify = function(s) {
  s = s.replace(/[^\w\s-]/g, '').trim().toLowerCase();
  s = s.replace(/[-\s]+/g, '-');
  return s;
};

ContentTree = function(filename) {
  var groups, plugin, _i, _len;
  groups = {
    directories: []
  };
  for (_i = 0, _len = contentPlugins.length; _i < _len; _i++) {
    plugin = contentPlugins[_i];
    groups[plugin.treeName] = [];
  }
  Object.defineProperty(this, '_', {
    get: function() {
      return groups;
    }
  });
  Object.defineProperty(this, 'filename', {
    get: function() {
      return filename;
    }
  });
  return Object.defineProperty(this, 'index', {
    get: function() {
      return this['index.md'] || this['index.markdown'];
    }
  });
};

ContentTree.fromDirectory = function(directory, base, callback) {
  var tree;
  if (!(callback != null)) {
    callback = base;
    base = directory;
  }
  tree = new ContentTree(path.relative(base, directory));
  return async.waterfall([
    async.apply(fs.readdir, directory), function(filenames, callback) {
      return async.forEach(filenames, function(filename, callback) {
        filename = path.join(directory, filename);
        return async.waterfall([
          async.apply(fs.lstat, filename), function(stats, callback) {
            var basename, i, match, plugin, relname, _i, _ref;
            if (stats.isDirectory()) {
              return ContentTree.fromDirectory(filename, base, function(error, result) {
                tree[path.relative(directory, filename)] = result;
                tree._.directories.push(result);
                return callback(error);
              });
            } else if (stats.isFile()) {
              basename = path.basename(filename);
              relname = path.relative(base, filename);
              match = false;
              for (i = _i = _ref = contentPlugins.length - 1; _i >= 0; i = _i += -1) {
                plugin = contentPlugins[i];
                if (minimatch(relname, plugin.pattern, {
                  dot: false
                })) {
                  plugin["class"].fromFile(relname, base, function(error, instance) {
                    if (!error) {
                      tree[basename] = instance;
                      tree._[plugin.treeName].push(instance);
                    }
                    return callback(error);
                  });
                  match = true;
                  break;
                }
              }
              if (!match) {
                logger.verbose("no plugin to handle " + filename);
                return callback();
              }
            } else {
              return callback(new Error("invalid file " + filename));
            }
          }
        ], callback);
      }, callback);
    }
  ], function(error) {
    return callback(error, tree);
  });
};

ContentTree.inspect = function(tree, depth) {
  var i, k, pad, rv, s, v, _i;
  if (depth == null) {
    depth = 0;
  }
  /* return a pretty formatted string representing the content *tree*
  */

  rv = [];
  pad = '';
  for (i = _i = 0; 0 <= depth ? _i <= depth : _i >= depth; i = 0 <= depth ? ++_i : --_i) {
    pad += '  ';
  }
  for (k in tree) {
    v = tree[k];
    if (v instanceof ContentTree) {
      s = ("" + k + "/\n").bold;
      s += ContentTree.inspect(v, depth + 1);
    } else if (v.template != null) {
      s = k.green + (" (url: " + v.url + ", template: " + v.template + ")").grey;
    } else if (v instanceof StaticFile) {
      s = k + (" (url: " + v.url + ")").grey;
    } else {
      s = k + (" (url: " + v.url + ")").cyan;
    }
    rv.push(pad + s);
  }
  return rv.join('\n');
};

util = require('util');

ContentTree.flatten = function(tree) {
  /* return all the items in the *tree* as an array of content plugins
  */

  var key, rv, value;
  rv = [];
  for (key in tree) {
    value = tree[key];
    if (value instanceof ContentTree) {
      rv = rv.concat(ContentTree.flatten(value));
    } else {
      rv.push(value);
    }
  }
  return rv;
};

module.exports.ContentTree = ContentTree;

module.exports.ContentPlugin = ContentPlugin;

module.exports.registerContentPlugin = registerContentPlugin;
